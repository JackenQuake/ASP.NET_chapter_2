### Tasks description for Lesson 4:

#### Комментарии:

Задания к уроку 4 выполнены.

В этом задании я попробовал шире использовать generic, о котором говорилось на лекции, для построение красивой иерархии классов. В частности, я сделал обобщенный репозиторий `GenericRepository` и преобразователь типов `GenericMapper<TDto, TStorage>`, реализующие основные операции CRUD (создать, прочитать, обновить и удалить 1 элемент). Если более сложной обработки не требуется, а требуется просто предоставлять контроллеру средства чтения-записи в БД - на них вполне можно опираться. Операции же чтения нескольких элементов требуют накладывать условия на поля, которые уже существенно зависят от конкретной задачи, поэтому их предлагается делать в унаследованных классах. Но `GenericMapper` предлагает для этого удобный метод `MassMap()`, который копирует возвращаемый репозиторием IEnumerable в List с преобразованием классов из TStorage в TDto.

С другой стороны, я хотел сохранить и сделанную в прошлый раз простую реализацию репозитория на базе List - чтобы в программе было две разных реализации одного и того же набора интерфейсов. Вероятно, в этом не очень много практической пользы, но пока задание учебное - мне кажется, это красиво. Поэтому сейчас они находятся в Namespace'ах `Repositories.List` и `Repositories.Database`, и для переключения между ними достаточно в начале Startup поменять соответствующий using - чтобы CreateSingleton связал с интерфейсом нужную из двух реализаций.

Я хотел сделать, как и раньше, чтобы разные типы запросов детализировались на уровне Model, а на уровень Repository передается предикат для отбора записей. К сожалению, у меня не получилось создать предикат в одной функции и передать в другую - тогда LINQ не может его скомпилировать. Работает только создание предиката непосредственно в аргументе Where. Даже очень простой пример отбора всех записей
```
Where(x => true)
```
работает, а
```
Predicate <DB) filter = x => true;
Where(filter)
```
не работает. Поэтому в реализации List остался универсальный метод Get, принимающий любой предикат, а в реализации Database так не вышло.

И, кроме того, я хотел избежать дублирования кода для Users и Employee - по сути это два разных экземпляра одной конструкции, Person, которая появилась еще в прошлом задании. Создать два экземпляра непосредственно было бы нетрудно, но для совместимости с DI пришлось немного повозиться: унаследовать для них идентичные, но разноименные интерфейсы, чтобы каждый класс был привязан к своему интерфейсу, и выстроилиcь две параллельные цепочки Controller-Model-Repository.

В реализации GenericDatabase при этом пришлось задавать два generic-параметра - моя собственная структура PersonStorage и класс Database Entity, то есть User или Employee, поскольку именно через него происходит привязка к конкретной базе данных. Но за счет этого все-таки удалось сделать универсальный код.

Обработку ошибок (таких как "запись в БД не найдена") я сделал через механизм Exceptions, которые возникают на уровне Repository и обрабатываются на уровне Controller. Но сначала я для этого использовал стандартный ArgumentException, и в результате мне стало трудно отделять эти ошибки от других ошибок в моем коде. Поэтому я сделал свои классы исключений, они находятся в Repository/Exceptions.cs. По этим исключениям контроллеры возвращают пользователям содержательные ошибки (поскольку эти исключения связаны с "прикладными" ошибками пользователя - обращением к неверным данным). А вот в случае прочих исключений возвращается HTTP код 500 (InternalServerError), а содержание исключения пишется в лог для отладки.
